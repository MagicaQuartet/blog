---
title: Javascript - Operator
lang: ko
description: 연산자는 표현식을 대상으로 연산을 수행해 하나의 값을 만드는 기호입니다. 연산의 대상이 되는 표현식은 피연산자 라고 부릅니다. 자바스크립트에서 피연산자와 연산자가 결합한 코드 조각은 평가되어 하나의 값이 되기 때문에 표현식에 해당합니다.
meta:
  - property: og:title
    content: Javascript - Operator
  - property: og:description
    content: 자바스크립트의 연산자
  - property: og:image
    content: /images/javascript-logo.png
tags: ["javascript"]
---

![Javascript-logo](/images/javascript-logo.png)

# Javascript - Operator

## 연산자

**연산자(Operator)** 는 표현식을 대상으로 연산을 수행해 하나의 값을 만드는 기호입니다. 연산의 대상이 되는 표현식은 **피연산자(Operand)** 라고 부릅니다.

저번 포스팅에서 표현식은 평가되어 하나의 값이 되는 코드 조각이라고 했었죠? 피연산자와 연산자가 결합한 코드 조각도 평가되어 하나의 값이 되기 때문에 표현식입니다.

연산자는 필요한 피연산자의 수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 분류됩니다.

단항 연산자는 하나의 피연산자를 필요로 하며 다음과 같은 형태로 쓰입니다.

```
연산자 피연산자
피연산자 연산자
```

이항 연산자는 연산자의 양 옆에 각각 하나씩 피연산자가 배치됩니다.

```
피연산자 연산자 피연산자
```

삼항 연산자는 사실 연산자 수에 따른 분류라기 보다는 그냥 연산자 이름이라고 기억하는 편이 더 좋습니다. 왜냐하면 피연산자 3개를 필요로 하는 연산자는 조건 연산자 뿐이고, 일반적으로 조건 연산자는 삼항 연산자라고 불리기 때문입니다. 조건 연산자는 다음과 같은 형태로 사용합니다.

```
피연산자 ? 피연산자 : 피연산자
```

그럼 이제 자바스크립트에서 제공하는 연산자에는 어떤 것이 있는지 알아보도록 하겠습니다. 자주 쓰는 연산자 위주로 설명을 할 예정이니 자세한 정보를 원하시는 분은 [여기](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_Operators)를 참고하시기 바랍니다!

## 할당 연산자

**할당 연산자**는 이항 연산자로, **우변 피연산자의 값을 좌변 피연산자에 할당합니다.**

기본적인 할당 연산자는 등호(`=`)이지만, 그 외에 다른 연산자와 등호를 결합한 복합 할당 연산자도 있습니다.

```javascript
x = y; /* 기본 할당 연산자 */
x += y; /* 덧셈 할당 연산자. x = x + y */
x -= y; /* 뺄셈 할당 연산자. x = x - y */
x *= y; /* 곱셈 할당 연산자. x = x * y */
x /= y; /* 나눗셈 할당 연산자. x = x / y */
x %= y; /* 나머지 할당 연산자. x = x % y */
```

할당 연산자가 사용된 표현식은 좌변 피연산자(일반적으로는 변수)에 값을 할당하면서 상태 변화를 일으키는 side effect를 가지고 있기는 하지만, 본질적으로는 표현식이기 때문에 평가되어 하나의 값을 반환합니다. 여기서 그 값은 **우변 피연산자를 평가한 값**입니다. 참고로 변수에 할당되는 값과 표현식의 값은 다를 수 있으니 혼동하지 않도록 합시다!

단, 복합 할당 연산자를 사용한 표현식의 경우 기본 할당 연산자를 사용한 동등한 표현식에서의 우변 피연산자를 평가한 값을 가집니다. 말이 길어져서 복잡해 보이는데 그냥 이런겁니다.

```javascript
var x = 40;
var y = 2;
console.log((x += y)); /* Result: 42. x = x + y에서 x + y의 값 */
```

자바스크립트에서 할당 연산자는 유일하게 오른쪽에서 왼쪽으로 평가가 진행되도록 하는 연산자입니다. 그런 만큼 조금 독특한 부분이 있기 때문에 메커니즘을 짚고 넘어갈 필요가 있습니다.

```javascript
var a, b, c;
a = b = c = 1;
```

위 코드는 _유효한_ 자바스크립트 코드입니다. 할당 연산자 표현식이 어떻게 평가되는지 그 과정을 살펴보도록 합시다.

0. **할당식은 좌변이 먼저 평가됩니다. 그 뒤에 `=`를 기준으로 우변이 평가됩니다.**
1. 따라서 먼저 `a`라는 식별자가 존재하는 지를 평가하고 우변 피연산자인 `b = c = 1`이 평가됩니다.
1. `b = c = 1`는 1번과 마찬가지로 `b`가 먼저 평가된 뒤, `c = 1`이 평가됩니다.
1. `c = 1`도 같은 방식으로 평가되어, 변수 c에 1을 할당함과 동시에 1을 반환합니다.
1. 따라서 `b = c = 1`는 `b = 1`과 같게 되고, 변수 b에 1을 할당함과 동시에 1을 반환합니다.
1. 최종적으로 `a = b = c = 1`은 `a = 1`과 같게 되어 변수 a에 1을 할당함과 동시에 1을 반환합니다.

## 비교 연산자

**비교 연산자**는 **피연산자들을 비교하고 그 결과에 따라 `Boolean` 값을 반환합니다.** 비교 연산자의 종류에는 `==`, `!=`, `===`, `!==`, `>`, `>=`, `<`, `<=` 등이 있습니다. 참고로 `>=`와 `=>`는 전혀 다르니 주의하시기 바랍니다! `=>`는 비교 연산자가 아니고, 자바스크립트의 함수를 공부할 때 만날 수 있는 기호입니다.

```javascript
5 == 5; /* true */
3 != 5; /* true */
3 < 7; /* true */
5 >= 4; /* true */
```

대부분 다른 언어에서도 사용하는 표현이니 크게 낯설지는 않을 것입니다. 그런데 조금 이상한 연산자들이 눈에 띄네요. `===`, `!==` 이 친구들은 어떻게 다르길래 등호가 하나 더 붙어있는 걸까요?

이에 대해 설명하기 위해서는 우선 *자바스크립트의 타입 변환*에 대해 이해를 해야 합니다. 상당히 중요한 내용이니 나중에 따로 포스팅할 예정이지만, 연산자를 설명하면서 빠질 수 없는 내용이므로 이 포스팅에서도 조금씩 설명을 하도록 하겠습니다.

자바스크립트에서는 비교 연산자의 두 피연산자가 다른 형태일 경우 비교가 가능하도록 **피연산자를 적절한 타입으로 변환합니다.** 이와 관련해 다음과 같은 유명한 그림이 있습니다.

![Javascript-trinity](/images/the-javascript-trinity.jpg)

그리고 아래의 동등 비교는 모두 참입니다.

```javascript
42 == 42;
"42" == 42;
0 == false;
```

믿지 못하겠다면 당장 F12를 눌러 콘솔에서 직접 확인해보도록 합시다!

이처럼 개발자가 명시하지 않은, 자바스크립트 엔진에 의한 컨텍스트에 따른 타입 변환을 **암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)** 이라고 합니다. 그래서 *자료형까지 같은 값*인지 알아보기 위해서는 `==`만으로는 부족했습니다. 그래서 자료형의 일치 여부도 확인하는 `===`, `!==`연산자를 사용하게 된 것입니다.

### 동등 연산자 `==`, 부등 연산자 `!=`

아래의 표현식은 모두 `true`를 반환합니다.

```javascript
42 == "42" /* true */
0 == false /* true */
2 != true  /* true */
{} != {}   /* true */
null == undefined /* true */
0 != null  /* true */
NaN != NaN /* true */
```

- 두 피연산자가 각각 `Number`와 `String` 값일 경우, `String` 값이 `Number` 값으로 변환됩니다.
- 두 피연산자가 각각 `Number`와 `Boolean` 혹은 `String`과 `Boolean` 값일 경우, `true`는 1, `false`는 0으로 변환됩니다.
- 두 피연산자가 모두 `Object`일 경우, 두 피연산자가 메모리 상에서 같은 객체를 가리킬 경우 동일한 객체로 간주합니다. 그렇지 않을 경우 속성과 속성값이 같더라도 항상 다른 객체로 간주합니다.
- `null`과 `undefined`는 서로 동등합니다.
- `NaN`은 자기 자신을 포함하여 어떤 것과도 동등하지 않다.

... 몇 가지만 열거하였는데 벌써 정신이 조금 혼미해집니다. 타입 변환과 관계없는 내용은 기억해 둘 필요가 있지만, 타입 변환 때문에 일어나는 현상은 충분히 `===`, `!==` 연산자를 통해 피해갈 수 있습니다. 가끔은 암묵적 타입 변환이 편리하다고 느낄 때도 있겠지만 예측하기 어려운 부작용을 일으키기 쉽기 때문에 가급적이면 사용하지 않는 것이 좋습니다.

### 일치 연산자 `===`, 불일치 연산자 `!==`

일치 연산자와 불일치 연산자는 두 피연산자의 자료형이 달라도 암묵적 타입 변환을 하지 않습니다. 즉, **타입 변환 없이도 같은 값(strict equal)** 인지를 확인합니다.

```javascript
0 === 0; /* true */
0 === "0"; /* false */
0 === false; /* false */
null === undefined; /* false */
```

이제 *대충 같은 값*이 아니라 *진짜로 같은 값*인지 확실하게 알아볼 수 있습니다! 이처럼 암묵적 타입 변환에 따른 부작용이 없기 때문에 동등/부등 연산자 대신 일치/불일치 연산자를 사용할 것을 _강력히_ 권장합니다.

## 산술 연산자

**산술 연산자**는 **숫자 값을 피연산자로 갖고, 하나의 숫자 값을 반환합니다.** 산술 연산자에는 기본적인 산술 연산자인 덧셈 `+`, 뺄셈 `-`, 곱셈 `*`, 나눗셈 `/`과 그 외에 나머지 `%`, 증가 `++`, 감소 `--` 등이 있습니다.

각 연산자에 대한 설명을 간략하게 하고 넘어가도록 하겠습니다.

### 사칙연산 연산자 `+`, `-`, `*`, `/`

주어진 두 `Number` 및 `Boolean` 피연산자의 사칙연산 결과 값을 반환합니다. `true`는 1, `false`는 0으로 간주됩니다. 만약 피연산자 중에 `String` 값이 있다면 `+`를 제외한 연산자는 `NaN`을 반환합니다. `+`의 경우 두 피연산자를 연결한 `String` 값이 반환되며, 이처럼 `+`가 문자열을 연결하는 역할을 할 경우 이를 *문자열 연산자*라고도 부릅니다.

```javascript
1 + 2; /* 3 */
true - 2; /* -1 */
3 * 4; /* 12 */
5 / 2; /* 2.5 */
5 + "string"; /* "5string" */
"string" + false; /* "stringfalse" */
```

### 나머지 연산자 `%`

좌변 피연산자를 우변 피연산자로 나누었을 때의 나머지를 반환하며 결과 값의 부호는 항상 좌변 피연산자의 부호와 동일합니다.

```javascript
(12 % 5) /* 2 */ - (12 % 5); /* -2 */
(12 % -5) /* 2 */ - (12 % -5); /* -2 */
```

### 거듭제곱 연산자 `**`

_거듭제곱 연산자는 ES7(ES2016)에서 추가되었습니다._

좌변 피연산자를 밑으로, 우변 피연산자를 지수로 한 값을 반환합니다. 이 때 좌변 피연산자에는 `+`, `-`을 비롯한 어떤 단항 연산자도 배치할 수 없습니다.

```javascript
4 ** 2; /* 16 */
4 ** -2 /* 0.0625 */ - 4 ** 2 /* Invalid expression */ - 4 ** 2; /* -16 */
```

### 증감 연산자 `++`, `--`

증가 연산자 `++`와 감소 연산자 `--`는 단항 연산자로, 피연산자를 1씩 증가/감소시킵니다. 반환하는 값은 연산자의 위치에 따라 다릅니다.

- 연산자가 피연산자 앞에 있을 경우, 증가/감소하기 전의 값을 반환합니다.
- 연산자가 피연산자 뒤에 있을 경우, 증가/감소한 후의 값을 반환합니다.

```javascript
var incrementPrefix = (incrementPostfix = 5);
var decrementPrefix = (decrementPostfix = 5);
++incrementPrefix; /* Result is 6, incrementPrefix is 6 */
incrementPostfix++; /* Result is 5, incrementPostfix is 6 */
--decrementPrefix; /* Result is 4, decrementPrefix is 4 */
decrementPostfix--; /* Result is 5, decrementPrefix is 4 */
```

## 논리 연산자

자바스크립트의 논리 연산자로는 논리 AND `&&`, 논리 OR `||`, 논리 NOT `!`이 있습니다. 다른 많은 언어에서는 `&&`는 두 피연산자가 모두 참인지, `||`는 두 피연산자 중 하나 이상이 참인지, 그리고 `!`은 주어진 피연산자가 참일 경우 거짓, 거짓일 경우 참을 반환하는 연산자입니다. 자바스크립트에서도 크게 다르지는 않겠죠? 그러나 이게 끝이 아니고, 꼭 알아두고 넘어가야 하는 중요한 내용이 숨어있습니다.

일반적으로 논리 연산자라고 하면 `Boolean` 피연산자를 받아서 `Boolean` 값을 반환하는 연산자라고 생각하기 쉽습니다. 그러나 자바스크립트의 논리 연산자는 큰 틀에서는 비슷하지만, 동작 과정에서 조금 차이가 있습니다. 부정 연산자 `!`를 제외하면, 피연산자가 `Boolean` 값이 아닐 수도 있고 반환값이 `Boolean` 값이 아닐 수도 있습니다.

### Truthy 값, Falsy 값

자바스크립트에서는 **명시적인 `Boolean` 값이 아니어도 문맥에 따라 `Boolean` 값으로 평가될 수 있습니다.** 조건문 및 반복문의 조건, 그리고 **논리 연산자의 피연산자**가 이러한 문맥에 해당합니다. `true`로 평가되는 값은 **truthy** 값, `false`로 평가되는 값은 **falsy** 값이라고 부릅니다.

명시적으로 falsy 값으로 정의되지 않은 값은 모두 truthy 값입니다. 자바스크립트의 falsy 값은 다음과 같습니다.

- `false`
- `null`
- `undefined`
- `NaN`
- `''`
- 0

참고로 빈 `String` 값과는 달리 빈 배열이나 `Object`는 falsy가 아닙니다.

이처럼 모든 값은 문맥에 따라 `Boolean`으로 평가될 수 있기 때문에 논리 연산자의 피연산자에 `Boolean`이 아닌 값이 올 수 있는 것입니다.

### 단축 평가 (Short-Circuit Evaluation)

그럼 피연산자는 그렇다치고, 반환값은 `Boolean` 값이 되어야할 것 같지 않나요? 아무튼 피연산자들을 참 같은 값, 거짓 같은 값으로 바꾸어서 논리 연산을 하니까요.

이에 대해 설명하기에 앞서 논리 연산자 표현식의 평가가 어떻게 진행되는 지를 살펴봅시다.

```javascript
"Cat" && "Dog";
"Cat" || "Dog";
undefined && 42;
undefined || 42;
```

`||`연산자의 경우 두 연산자 중 truthy 값이 하나라도 있으면 참을 나타내게 됩니다. 그렇다면 좌변 피연산자가 truthy 값이라면 우변 피연산자는 볼 필요도 없이 그 표현식은 참이 됩니다. 따라서 이러한 경우 우변 피연산자를 평가하지 않은 채 그대로 표현식의 평가가 종료됩니다.

반면 `&&` 연산자는 두 연산자가 모두 truthy 값이여야 참이 됩니다. 따라서 좌변 피연산자가 falsy 값이라면 우변 피연산자와 상관없이 표현식의 평가 결과는 거짓이 될 것이고, 우변 피연산자를 평가하지 않고 평가를 끝냅니다.

이처럼 **논리 연산 결과가 결정되는 시점에 표현식의 평가를 끝내는 방식**을 **단축 평가 (Short-Circuit Evaluation)** 라고 합니다. 사실 단축 평가 자체는 다른 언어의 논리 연산에서도 사용되는 방식입니다. 그런데 자바스크립트에서 특이한 점은, **`&&`연산자와 `||` 연산자가 반환하는 값은 논리 연산 결과를 결정한 피연산자의 값**이라는 점입니다. 즉, 위 예시의 결과값은 다음과 같습니다.

```javascript
"Cat" && "Dog"; /* "Dog" */
"Cat" || "Dog"; /* "Cat" */
null && 42; /* null */
null || 42; /* 42 */
```

그런데 반환하는 값이 `Boolean`이 아니면, 어떻게 조건문이나 반복문에서 이러한 표현식을 쓸 수 있을까요? 조건이 `true`거나 `false`여야 블록 내부의 코드를 실행할지 말지를 판단할텐데요.

```javascript
if ("Cat" && "Dog") { ... }
```

답은 간단합니다. 조건이 위치하는 곳도 역시 `Boolean`으로의 변환이 일어날 수 있는 컨텍스트인 것입니다. `"Cat" && "Dog"`의 값은 `"Dog"`이고, 길이가 0 이상인 `String` 값은 truthy 값이므로 블록 내부의 코드를 실행하게 됩니다.

참고로 이러한 성질을 이용하여 주어진 변수나 함수 인자가 유효한 값인지 (주로 `null`이나 `undefined`가 아닌지) 확인하는 패턴이 사용되니 한번쯤 봐두면 좋습니다.

```javascript
var elem;
console.log(elem.value); /* Error */
console.log(elem && elem.value); /* undefined */

function getStringLength(str) {
  var _str = str || "";
  return _str.length;
}
```

그런데 단축 평가 설명에서 논리 NOT `!` 연산자 얘기는 쏙 빠져있군요. `&&`, `||`와는 달리 `!` 연산자는 반환값이 항상 `Boolean` 값입니다. 피연산자가 truthy 값이면 `false`, falsy 값이면 `true`를 반환합니다.

정리하면, 자바스크립트의 논리 연산자가 하는 역할은 다음과 같습니다.

### 논리 AND `&&`

이항 연산자로, 좌변 피연산자가 falsy 값인 경우 좌변 피연산자의 값을 반환하고 truthy 값인 경우 우변 피연산자의 값을 반환합니다.

```javascript
true && null; /* null */
null && false; /* null */
"Cat" && "Dog"; /* "Dog" */
```

### 논리 OR `||`

이항 연산자로, 좌변 피연산자가 truthy 값인 경우 좌변 피연산자의 값을 반환하고 falsy 값인 경우 우변 피연산자의 값을 반환합니다.

```javascript
true || null; /* true */
null || false; /* false */
"Cat" || "Dog"; /* "Cat" */
```

### 논리 NOT `!`

단항 연산자로, 피연산자가 truthy 값인 경우 `false`를 반환하고 falsy 값인 경우 `true`를 반환합니다.

## 조건 연산자

조건 연산자는 앞서 언급한 것처럼 3개의 피연산자를 필요로 하는 유일한 연산자이기 때문에 삼항 연산자로도 불립니다.

조건 연산자 표현식은 `condition ? expr1 : expr2`의 형태를 가집니다. 평가 결과는 `condition`이 truthy 값이면 `expr1`의 값, falsy 값이면 `expr2`의 값이 됩니다.

```javascript
var result = 42;
var isAnswer = result == 42 ? "Answer to everything" : "Nope";
console.log(isAnswer); /* "Answer to everything" */
```

*주어진 조건을 만족하면 이 값, 아니면 저 값*이라는 로직만을 구현하기 위해 `if-else` 블록을 만드는 건 조금 군더더기일 수 있겠죠? 그런 상황에서 조건 연산자를 유용하게 사용할 수 있습니다.

## Reference

- 표현식과 연산자 - Javascript | MDN [Link](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_Operators)
- Operator | PoiemaWeb [Link](https://poiemaweb.com/js-operator)
- Type coercion | PoiemaWeb [Link](https://poiemaweb.com/js-type-coercion)
- 자바스크립트의 할당연산자 고찰 | BSIDESOFT co. [Link](https://www.bsidesoft.com/?p=1975)

<Disqus/>
