---
title: Longest Increasing Subsequence
lang: ko
description: Longest Increasing Subsequence 주어진 수열에서 가장 긴 증가하는 부분수열의 길이, 혹은 그 부분수열을 찾는 알고리즘
meta:
  - property: og:title
    content: Longest Increasing Subsequence
  - property: og:description
    content: 가장 긴 증가하는 부분수열
tags: ["algorithm"]
shortDescription: 가장 긴 증가하는 부분수열
writtenDate: "2021-01-26 22:00:00"
modifiedDate: "2021-01-26 22:00:00"
---

## Longest Increasing Subsequence

주어진 수열의 일부 원소를 주어진 순서 그대로 나열한 것을 부분수열이라고 부릅니다.  
예를 들어 수열 `[5, 2, 3, 1, 4]`가 주어졌을 때, `[5, 2, 4]`, `[2, 3, 4]`, `[2]`는 부분수열이지만 `[3, 4, 1]`은 순서가 바뀌었기 때문에 부분수열이 아닙니다.

이 때 부분수열 중 원소가 오름차순이면서 가장 길이가 긴 것을 **Longest Increasing Subsequence**라고 하며, 보통 **LIS**로 줄여서 부릅니다. 위 수열의 경우 `[2, 3, 4]`가 유일한 LIS가 되겠네요.

## Naive Approach

단순한 방법으로는 모든 부분수열을 구한 뒤 그 중 원소가 오름차순이면서 가장 길이가 긴 것을 찾을 수 있습니다.  
그러려면 수열의 각 원소를 포함하거나 포함하지 않는 경우를 고려해야 하므로, 수열의 길이가 N이면 O(2<sup>N</sup>)겠네요.  
보기만해도 소름이 돋는 시간 복잡도니까 다른 방법을 찾아보도록 합시다.

## How It Works

오름차순이라 함은 왼쪽에서 오른쪽으로 갈수록 숫자가 커지는 것이기 때문에, 수열을 왼쪽부터 순회하면서 각 단계에 대해 그때까지의 LIS에 대한 정보를 잘만 유지하면 답을 찾아낼 수 있지 않을까 짐작할 수 있습니다.  
예컨대 `[5, 2, 3, 1, 4]`를 왼쪽부터 순회하다가 마지막 `4`에 이르렀을 때, 그때까지의 LIS가 `[2, 3]`임을 어케어케 잘 알고있으면 이제 `[2, 3, 4]`가 LIS가 되는 것을 알 수 있다는 뜻입니다.

> A (길이 N): 주어진 배열  
> lis (길이 N): LIS 후보들을 담는 배열?

lis는 위에서 말한 _그때까지의 LIS_ 정보를 담는 데에 사용합니다. 역할이 다소 모호하게 써있는데, 그 이유는 아래에서 설명드릴 예정입니다.

lis의 모든 원소를 -1로 초기화 한 후 A를 순회합니다.  
각 원소 A[i]를 방문할 때 마다, lis를 왼쪽부터 확인하여 <U>A[i]보다 큰 값이나 -1이 나오면 이를 A[i]로 대체합니다.</U>

`[5, 2, 3, 1, 4]`을 A로 하여 위 알고리즘을 돌려보겠습니다.

|     |                   |
| --- | ----------------- |
| A   | **5** 2 3 1 4     |
| lis | **5** -1 -1 -1 -1 |

|     |                   |
| --- | ----------------- |
| A   | 5 **2** 3 1 4     |
| lis | **2** -1 -1 -1 -1 |

이렇게 기존에 lis에 있던 -1이 아닌 값을 더 작은 값으로 대체하는 이유는  
LIS 후보의 앞쪽에 최대한 작은 값이 있어야 LIS를 형성하기에 유리하기 때문입니다.  
방금 단계에서 5를 그대로 두면 더이상 어떤 원소와도 오름차순으로 연결될 수 없지만, 2의 경우 연결 가능한 원소가 많죠.

|     |                  |
| --- | ---------------- |
| A   | 5 2 **3** 1 4    |
| lis | 2 **3** -1 -1 -1 |

|     |                  |
| --- | ---------------- |
| A   | 5 2 3 **1** 4    |
| lis | **1** 3 -1 -1 -1 |

|     |                 |
| --- | --------------- |
| A   | 5 2 3 1 **4**   |
| lis | 1 3 **4** -1 -1 |

알고리즘이 종료되면 lis에는 `[1, 3, 4]`가 남습니다. 그럼 이게 수열 A의 LIS겠네요.

...아쉽지만 **아닙니다!**  
A에는 `[1, 3, 4]`가 순서대로 들어있지 않습니다. 그럼 대체 이 알고리즘으로 알아낼 수 있는 것은 무엇일까요?

결론부터 말하면, **LIS의 길이**입니다.  
아까 배열 lis의 역할을 _LIS 후보들을 담는 배열?_ 이라고 표현했는데,  
정확히는 **lis[j]가 -1이 아닐 때, 길이가 j이고 마지막 원소가 lis[j]인 증가하는 부분수열이 존재함**을 나타내는 배열입니다.  

즉, 위에서 구한 `[1, 3, 4]`는 1로 끝나는 길이 1의 부분수열, 3으로 끝나는 길이 2의 부분수열, 4로 끝나는 길이 3의 부분수열이 존재함을 뜻합니다. 그러므로, 아직 뭔지는 몰라도 LIS의 길이는 3임이 보장됩니다.

여기서 약간의 장치를 추가하면 LIS가 무엇인지도 찾을 수 있습니다.

> parent (길이 N): 어떤 원소가 lis에 기록될 때, 그 원소 앞에 위치한 원소에 대한 정보를 나타내는 배열

A[i]를 lis에 기록할 때, 어떤 경우든 lis에서 A[i] 바로 앞에 위치하는 수는 어떤 증가하는 부분수열에서 A[i] 앞에 오는 수가 됩니다. 왜냐하면 lis[j]는 현재 시점에서 길이가 j이고 마지막 원소가 lis[j]인 증가하는 부분수열이 존재함을 나타내기 때문입니다.  
따라서 lis[j+1]에 A[i]를 기록하면, 이는 lis[j] < A[i]을 뜻하므로 A[i]을 포함하는 증가하는 부분수열에는 A[i] 바로 앞에 lis[j]가 위치할 수 있습니다.  
이를 이용하여 lis에 기록할 때 parent를 함께 갱신하는 방식으로 parent를 완성할 수 있고, parent를 활용하여 lis에 저장된 -1이 아닌 수 중 가장 오른쪽에 있는 숫자부터 시작해서 LIS를 역추적할 수 있습니다.

구현 방법은 여러가지가 있을 텐데, 저는 lis와 parent에 원소값 대신 인덱스를 저장하고, lis[j+1]에 i를 기록하면 parent[i]에는 lis[j]를 저장한 후 알고리즘이 종료되면 인덱스를 이용해 LIS를 구하는 방식을 사용합니다.

## Time Complexity

A를 순회하면서(O(N)) 각 방문마다 lis를 순회하므로(O(N)) 총 시간 복잡도는 O(N<sup>2</sup>)입니다. 처음보다 훨씬 낫군요.

그런데 시간 복잡도를 한번 더 개선할 수 있습니다.  
잘 생각해보면, lis에 저장되는 수는 -1을 제외하면 항상 오름차순임을 알 수 있습니다.
* -1을 A[i]로 대체한 경우, 그 앞에 있는 수는 모두 A[i]보다 작음
* -1이 아닌 수 lis[j]를 A[i]로 대체한 경우, lis[j] < A[i]이고 lis[j+1] == -1이거나 A[i] < lis[j+1] 이므로 오름차순 유지
  
그러므로, A[i]이 들어갈 위치를 이분 탐색으로 찾아낼 수 있습니다. 따라서, 각 방문마다 수행하는 lis 탐색은 O(N)이 아닌 O(logN)으로 줄어듭니다.  
결국 개선된 시간 복잡도는 O(NlogN)입니다.

parent 배열이 추가되어도 parent 갱신은 A의 각 원소를 방문할 때마다 1번까지 일어날 수 있으므로 O(N)이 추가되는 것이기 때문에 시간 복잡도에는 영향이 없습니다.

## Related Problems

[[BOJ 12015] 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)  
[[BOJ 1365] 꼬인 전깃줄](https://www.acmicpc.net/problem/1365)  
[[BOJ 14003] 가장 긴 증가하는 부분 수열 5](https://www.acmicpc.net/problem/14003)  
[[BOJ 11054] 가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)
